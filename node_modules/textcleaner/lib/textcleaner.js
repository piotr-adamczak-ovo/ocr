'use strict';

/**
 * Module dependencies.
 */

var utils = require('./utils');
var exec = require('child_process').exec;
var fs = require('fs');
var tmpdir = require('os').tmpdir(); // let the os take care of removing zombie tmp files
var uuid = require('node-uuid');
var path = require('path');
var glob = require("glob");
var Jimp = require("jimp");
var lwip = require('lwip');

var MeterType = {
	  Dark : {value: 0, min: 80, name: "Dark", contrast: 0.7, brightness: 0.45, grayscale:0}, 
	  Medium: {value: 1, min: 130, name: "Medium", contrast: 0.92, brightness: 0.35, grayscale:1}, 
	  Light : {value: 2, min: 180, name: "Light", contrast: 0.7, brightness: 0.45, grayscale:0}
};



var Textcleaner = {

	tmpFiles: [],

	/**
	 * options default options passed to Textcleaner binary
	 * @type {Object}
	 */
	options: {
		'binary': __dirname+'/../bin/textcleaner'
	},

	/**
	 * outputEncoding
	 * @type {String}
	 */
	outputEncoding: 'UTF-8',

	/**
	 * Runs Textcleaner binary with options
	 *
	 * @param {String} image
	 * @param {Object} options to pass to Textcleaner binary
	 * @param {Function} callback
	 */
	process: function(image, callback) {

		// generate output file name
		var output = path.resolve(tmpdir, 'node-textcleaner_first_1-' + uuid.v4()+'.jpg');
 
		isImageDark(image, function(meterType) {
			 Jimp.read(image).then(function (image) {


					if (meterType == MeterType.Dark) {
							console.log("Invert image colors");
							image.invert();
					} 

					if (meterType.grayscale) {
							image.grayscale();
					} 

					if (meterType == MeterType.Medium) {
							image.brightness(meterType.brightness); 
							image.contrast(meterType.contrast);
					} else {
							image.contrast(meterType.contrast);
							image.brightness(meterType.brightness); 
						}

					// image.posterize(5);

					image.autocrop();
		
					image.write(output, function(cb) {
							performTextCleaner(output, callback);
					});

			}).catch(function (err) {
					callback(err, null);
			});
		});    
	}
 };

	function performTextCleaner(image, callback) {

		var output = path.resolve(tmpdir, 'node-textcleaner_first_2-' + uuid.v4()+'.jpg');
		Textcleaner.tmpFiles.push(output);
	
		// assemble Textcleaner command
		var command = [Textcleaner.options.binary]

		command.push('-g -e stretch -f 25 -o 10 -u -s 1 -T');
		// add input and output
		command.push(image);
		command.push(output);

		command = command.join(' ');

		console.log('Textcleaner: command')
		console.log(command);

		var opts = Textcleaner.options.env || {};

		// Run the Textcleaner command
		exec(command, opts, function(err) {
			if (err) {
				// Something went wrong executing the assembled command
				callback(err, null);
				return;
			}

			// Find one of the three possible extension
			glob(output, function(err, files){
				if (err) {
					callback(err, null);
					return;
				}

				// we have got transformed image path
				callback(null, output);
			})
		}); // end exec
	}

function gc() {
	for (var i = Textcleaner.tmpFiles.length - 1; i >= 0; i--) {
		try {
			fs.unlinkSync(Textcleaner.tmpFiles[i] + '.txt');
		} catch (err) {}

		var index = Textcleaner.tmpFiles.indexOf(Textcleaner.tmpFiles[i]);
		if (~index) Textcleaner.tmpFiles.splice(index, 1);
	};
}

var version = process.versions.node.split('.').map(function(value) {
	return parseInt(value, 10);
});

if (version[0] === 0 && (version[1] < 9 || version[1] === 9 && version[2] < 5)) {
	process.addListener('uncaughtException', function _uncaughtExceptionThrown(err) {
		gc();
		throw err;
	});
}

// clean up the tmp files
process.addListener('exit', function _exit(code) {
	gc();
});

function isImageDark(image, callback) {
		var checkingPoints = []
		lwip.open(image, "jpg", function(err, img) {

				var width = img.width();
				var height = img.height();

				var pixels = arrayOfPixelsToCheck(width, height);

				var dark = 0;
				var medium = 0;
				var light = 0;

				for(var i=0; i<pixels.length; i++) {
						var pixel = pixels[i];
						pixel.color = img.getPixel(pixel.x,pixel.y);
						pixels[i] = pixel;

						var grayValue = getGrayscaleValue(pixel.color);


						if (grayValue < MeterType.Dark.min) {
								dark++;
						} else if (grayValue < MeterType.Medium.min) {
								medium++;
						} else {
								light++;
						}
				}

				var meterType;

				if (dark > medium && dark > light) {
					  meterType = MeterType.Dark;
				} else if (medium > dark && medium > light) {
						meterType = MeterType.Medium;
				} else {
						meterType = MeterType.Light;
				}
			
				// console.log(pixels);
				console.log('Meter type '+meterType.name);

				callback(meterType);
		});

	function arrayOfPixelsToCheck(width, height) {

		var points = [];

		var dividerPerWidth = 7;
		var dividerPerHeight = 3;

		var gapX = width / (dividerPerWidth + 1);
		var x = gapX;

		var gapY = height / (dividerPerHeight + 1);
		var y = gapY;

		var level = 1;

		for (var level = 0; level < dividerPerHeight; level++) {

			for (var col = 0; col < dividerPerWidth; col++) {
					points.push(new Point(x,y));
					x+=gapX;
			}

			x = gapX;
			y += gapY;
		}

		return points;
	}

	function getGrayscaleValue(color){
		var yiq = ((color.r*299)+(color.g*587)+(color.b*114))/1000;
		return yiq;
	}

	function Point(x, y) {
		this.x = parseInt(x);
		this.y = parseInt(y);
		this.color = -1;
	}
};

/**
 * Module exports.
 */
module.exports.process = Textcleaner.process;
