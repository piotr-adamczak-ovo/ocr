'use strict';

/**
 * Module dependencies.
 */

var utils = require('./utils');
var exec = require('child_process').exec;
var fs = require('fs');
var tmpdir = require('os').tmpdir(); // let the os take care of removing zombie tmp files
var uuid = require('node-uuid');
var path = require('path');
var glob = require("glob");
var Jimp = require("jimp");
var lwip = require('lwip');
var utils = require('utils');

//best for dark 04944 : 
    // b_0.6_c_-0.1_p_4  49445774
    // b_0.6_c_0.6_p_4  0494411
    // b_0.6_c_0.5_p_4  04944152
    // b_0.7_c_0.4_p_5_ 0494415

    //best for dark 019676
    // b_0.6_c_0.8_p_5_01967931

    //best for medium 21138 : 
    // b_0.4_c_0.8_p_5_1388
    // b_0.4_c_0.8_p_5_1388.jpg
    // b_0.4_c_0.85_p_15_8138

    //best for dark 9373
    // meter_photo_b_0.1_c_0.6_p_5_93133

var MeterType = {
	  Dark : {value: 0, min: 60, 	 name: "Dark", 	 steps: [{contrast: 0.8, brightness: 0.4, posterize:5, grayscale:0},
	   																										 {contrast: 0.8, brightness: 0.1, posterize:5, grayscale:0},
	  																										 {contrast: 0.7, brightness: 0.2, posterize:5, grayscale:0},
																										 	   {contrast: 0.4, brightness: 0.1, posterize:5, grayscale:0},
																										    ]},

	  Medium: {value: 1, min: 130, name: "Medium", steps: [{contrast: 0.8, brightness: 0.4, posterize:5, grayscale:0},
																										 		 {contrast: 0.6, brightness: 0.5, posterize:5, grayscale:0},
																										 	 	 {contrast: 0.4, brightness: 0.6, posterize:5, grayscale:0}]},

	  Light : {value: 2, min: 180, name: "Light",  steps: [{contrast: 0.33, brightness: 0.9, posterize:5, grayscale:0},
																										 		 {contrast: 0.55, brightness: 0.7, posterize:5, grayscale:0},
																										 	 	 {contrast: 0.75, brightness: 0.5, posterize:5, grayscale:0}]}
};

var Textcleaner = {

	tmpFiles: [],

	/**
	 * options default options passed to Textcleaner binary
	 * @type {Object}
	 */
	options: {
		'binary': __dirname+'/../bin/textcleaner'
	},

	uploadPath: __dirname + "/../../../uploads/",
	/**
	 * outputEncoding
	 * @type {String}
	 */
	outputEncoding: 'UTF-8',
	/**
	 * Runs Textcleaner binary with options
	 *
	 * @param {String} image
	 * @param {Object} options to pass to Textcleaner binary
	 * @param {Function} callback
	 */

	benchmark: function(fullImage, brightness, contrast,posterize, callback) {

		var ds = utils.datetimestamp();
		var id = uuid.v4();

		// generate output file name
		var output = Textcleaner.uploadPath + 'meter_photo_b_' +brightness + '_c_' + contrast+ '_p_' + posterize +'_output.jpg';
	
			isImageDark(fullImage, function(meterType) {
				 Jimp.read(fullImage).then(function (image) {
				 		//third - perform image enhancement
						if (meterType == MeterType.Dark) {
								console.log("Invert image colors");
								image.invert();
						} 

						if (meterType.grayscale) {
								image.grayscale();
						} 

						if (meterType == MeterType.Medium) {
								image.brightness(brightness); 
								image.contrast(contrast);
						} else {
								image.contrast(contrast);
								image.brightness(brightness); 
						}

						if (posterize > 0) {
							image.posterize(posterize);
						}

						image.autocrop();
			
						var isLcd = (meterType == MeterType.Medium);

						image.write(output, function(cb) {
								performTextCleaner(output,isLcd,brightness,contrast,posterize, callback);
						});

				}).catch(function (err) {
						callback(err, null);
				});
			});   
 	},

	process: function(fullImage, cropRect, callback) {

		var ds = utils.datetimestamp();
		var id = uuid.v4();

		// generate output file name
		var cropped = Textcleaner.uploadPath + 'meter_photo_' +ds+ '_cropped_' + uuid.v4()+'.jpg';
		var output;

		var stepsImages = [];
		var preprocessedImages = [];
		var imagePreprocessed = 0;

		//first - read image and crop it
		Jimp.read(fullImage).then( function(cropImage) {

				if (cropRect != null) {
						cropImage.crop(cropRect.x, cropRect.y, cropRect.width, cropRect.height);
				}
				cropImage.write(cropped, function(cb) {

						//second - check if meter read is dark, medium or light
						isImageDark(cropped, function(meterType) {

							var steps = meterType.steps;
							var preprocessed = [];
							var cleared = [];
 							preprocessNextImage(cropped, meterType, 0, steps, preprocessed, function(imagesAfterOperations) {
 									console.log('Preprocessed images: '+imagesAfterOperations.length);

 									cleanNextImage(imagesAfterOperations,0,cleared, function(clearedImages) {
 											console.log('Cleared images: '+clearedImages.length);
 											callback(clearedImages);
 									});
 							});
						});   
				});
		});
   }
 };

 function preprocessNextImage(source, meterType, index, steps, results, callback) {

 		if (index >= steps.length) {
 				callback(results);
 				return;
 		}
	
		console.log("Current step: "+index);

 		preprocessImageWithSteps(source,meterType,index,steps[index],function(image) {
 				results.push(image);
 				preprocessNextImage(source,meterType,index+1, steps, results,callback);
 		});
 }


 function preprocessImageWithSteps(source, meterType, index, step, callback) {
 	 var ds = utils.datetimestamp();
	 var id = uuid.v4();
	 var output = Textcleaner.uploadPath + 'meter_photo_' +ds+ '_' + uuid.v4()+ '_step_'+index+'_b' +step.brightness + '_c_' + step.contrast+ '_p_' + step.posterize +'.jpg';

 	 Jimp.read(source).then(function (image) {

			 		//third - perform image enhancement
					if (meterType == MeterType.Dark) {
							console.log("Invert image colors");
							image.invert();
					}
					
					if (step.grayscale) {
							image.grayscale();
					} 

					if (meterType == MeterType.Medium) {
							image.brightness(step.brightness); 
							image.contrast(step.contrast);
					} else {
							image.contrast(step.contrast);
							image.brightness(step.brightness); 
					}

					if (meterType.posterize > 0) {
							image.posterize(step.posterize);
					}
					
					image.autocrop();

					var isLcd = (meterType == MeterType.Medium);

					image.write(output, function(cb) {
							var imageObject = new utils.ImageForOCR(output, isLcd, step);
							callback(imageObject);
					});

			}).catch(function (err) {
					console.log(err);
					callback(null);
			});
 }

function cleanNextImage(images, index, results, callback) {

 		if (index >= images.length) {
 				callback(results);
 				return;
 		}

 		console.log("Current step of cleaning: "+index);

 		cleanImage(images[index],function(err,image) {
 				results.push(image);
 				cleanNextImage(images, index+1, results,callback);
 		});
 }

 function cleanImage(image, callback) {

		var path = image.path;
		var lcd = image.isLcd;
		var step = image.step;
		
		performTextCleaner(path, lcd, step.brightness, step.contrast, step.posterize,function(err, isLcd, preprocessedImage) {
				var image = new utils.ImageForOCR(preprocessedImage, isLcd, step);
				callback(err,image);
  	});
}

	function performTextCleaner(image, isLcd, brightness, contrast,posterize, callback) {

		var ds = utils.datetimestamp();
		var id = uuid.v4();
		// generate output file name
		var output = Textcleaner.uploadPath + 'meter_photo_' +ds+ '_textcleaner_' + uuid.v4()+'.jpg';

		if (brightness != null || contrast != null || posterize != null) {
				output = Textcleaner.uploadPath + 'meter_photo_' + id+ 'b_' +brightness + '_c_' + contrast+ '_p_' + posterize +'_clean.jpg';
		}

		Textcleaner.tmpFiles.push(output);
	
		// assemble Textcleaner command
		var command = [Textcleaner.options.binary]

		//-g -e stretch -f 25 -o 10 -u -s 1 -T
		command.push('-g -e stretch -f 25 -o 10 -u -s 1 -T');
		// add input and output
		command.push(image);
		command.push(output);

		command = command.join(' ');

		console.log('Textcleaner: command')
		console.log(command);

		var opts = Textcleaner.options.env || {};

		// Run the Textcleaner command
		exec(command, opts, function(err) {
			if (err) {
				// Something went wrong executing the assembled command
				callback(err, isLcd, null);
				return;
			}

			// Find one of the three possible extension
			glob(output, function(err, files){
				if (err) {
					callback(err, isLcd, null);
					return;
				}

				// we have got transformed image path
				callback(null, isLcd, output);
			})
		}); // end exec
	}

function gc() {
	for (var i = Textcleaner.tmpFiles.length - 1; i >= 0; i--) {
		try {
			fs.unlinkSync(Textcleaner.tmpFiles[i] + '.txt');
		} catch (err) {}

		var index = Textcleaner.tmpFiles.indexOf(Textcleaner.tmpFiles[i]);
		if (~index) Textcleaner.tmpFiles.splice(index, 1);
	};
}

var version = process.versions.node.split('.').map(function(value) {
	return parseInt(value, 10);
});

if (version[0] === 0 && (version[1] < 9 || version[1] === 9 && version[2] < 5)) {
	process.addListener('uncaughtException', function _uncaughtExceptionThrown(err) {
		gc();
		throw err;
	});
}

// clean up the tmp files
process.addListener('exit', function _exit(code) {
	gc();
});

function isImageDark(image, callback) {
		var checkingPoints = []

		console.log("Checking image brightness");

		lwip.open(image, "jpg",function(err, img) {

				if (err) {
					  console.error(err);
					  return;
				}

				var width = img.width();
				var height = img.height();

				var pixels = arrayOfPixelsToCheck(width, height);

				var dark = 0;
				var medium = 0;
				var light = 0;

				for(var i=0; i<pixels.length; i++) {
						var pixel = pixels[i];
						pixel.color = img.getPixel(pixel.x,pixel.y);
						pixels[i] = pixel;

						var grayValue = getGrayscaleValue(pixel.color);

						if (grayValue < MeterType.Dark.min) {
								dark++;
						} else if (grayValue < MeterType.Medium.min) {
								medium++;
						} else {
								light++;
						}
				}

				var meterType;

				console.log('Light: ' + light+ '  Medium: '+medium + '  Dark:' + dark);

				if (dark > medium && dark > light) {
					  meterType = MeterType.Dark;
				} else if (medium > dark && medium > light) {
						meterType = MeterType.Medium;
				} else {
						meterType = MeterType.Light;
				}
			
				// console.log(pixels);
				console.log('Meter type '+meterType.name);

				callback(meterType);
		});

	function arrayOfPixelsToCheck(width, height) {

		var points = [];

		var dividerPerWidth = 7;
		var dividerPerHeight = 3;

		var gapX = width / (dividerPerWidth + 1);
		var x = gapX;

		var gapY = height / (dividerPerHeight + 1);
		var y = gapY;

		var level = 1;

		for (var level = 0; level < dividerPerHeight; level++) {

			for (var col = 0; col < dividerPerWidth; col++) {
					points.push(new Point(x,y));
					x+=gapX;
			}

			x = gapX;
			y += gapY;
		}

		return points;
	}

	function getGrayscaleValue(color){
		var yiq = ((color.r*299)+(color.g*587)+(color.b*114))/1000;
		return yiq;
	}

  function Point(x, y) {
    this.x = parseInt(x);
    this.y = parseInt(y);
    this.color = -1;
  }

};

/**
 * Module exports.
 */
module.exports.process = Textcleaner.process;
module.exports.benchmark = Textcleaner.benchmark;
module.exports.version = Textcleaner.version;
