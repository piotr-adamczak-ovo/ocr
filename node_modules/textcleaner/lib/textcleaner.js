'use strict';

/**
 * Module dependencies.
 */

var utils = require('./utils');
var exec = require('child_process').exec;
var fs = require('fs');
var tmpdir = require('os').tmpdir(); // let the os take care of removing zombie tmp files
var uuid = require('node-uuid');
var path = require('path');
var glob = require("glob");
var Jimp = require("jimp");
var lwip = require('lwip');
var utils = require('utils');

//best for dark 04944 : 
// b_0.6_c_-0.1_p_4  49445774
// b_0.6_c_0.6_p_4  0494411
// b_0.6_c_0.5_p_4  04944152
// b_0.7_c_0.4_p_5_ 0494415
// b_0.7_c_0.6_p_5_0494411

var MeterType = {
	  Dark : {value: 0, min: 80, name: "Dark", contrast: 0.70, brightness: 0.58, posterize:5, grayscale:0}, 
	  Medium: {value: 1, min: 130, name: "Medium", contrast: 0.8, brightness: 0.4,posterize:5,  grayscale:1}, 
	  Light : {value: 2, min: 180, name: "Light", contrast: 0.55, brightness: 0.7,posterize:5,  grayscale:0}
};

var Textcleaner = {

	tmpFiles: [],

	/**
	 * options default options passed to Textcleaner binary
	 * @type {Object}
	 */
	options: {
		'binary': __dirname+'/../bin/textcleaner'
	},

	uploadPath: __dirname + "/../../../uploads/",
	/**
	 * outputEncoding
	 * @type {String}
	 */
	outputEncoding: 'UTF-8',

	/**
	 * Runs Textcleaner binary with options
	 *
	 * @param {String} image
	 * @param {Object} options to pass to Textcleaner binary
	 * @param {Function} callback
	 */

	benchmark: function(fullImage, brightness, contrast,posterize, callback) {

		var ds = utils.datetimestamp();
		var id = uuid.v4();

		// generate output file name
		var output = Textcleaner.uploadPath + 'meter_photo_b_' +brightness + '_c_' + contrast+ '_p_' + posterize +'_output.jpg';
	
			isImageDark(fullImage, function(meterType) {
				 Jimp.read(fullImage).then(function (image) {
				 		//third - perform image enhancement
						if (meterType == MeterType.Dark) {
								console.log("Invert image colors");
								image.invert();
						} 

						if (meterType.grayscale) {
								image.grayscale();
						} 

						if (meterType == MeterType.Medium) {
								image.brightness(brightness); 
								image.contrast(contrast);
						} else {
								image.contrast(contrast);
								image.brightness(brightness); 
						}

						if (posterize > 0) {
							image.posterize(posterize);
						}

						image.autocrop();
			
						image.write(output, function(cb) {
								performTextCleaner(output,brightness,contrast,posterize, callback);
						});

				}).catch(function (err) {
						callback(err, null);
				});
			});   
 	},

	process: function(fullImage, cropRect, callback) {

		var ds = utils.datetimestamp();
		var id = uuid.v4();

		// generate output file name
		var cropped = Textcleaner.uploadPath + 'meter_photo_' +ds+ '_cropped_' + uuid.v4()+'.jpg';
		var output = Textcleaner.uploadPath + 'meter_photo_' +ds+ '_output_' + uuid.v4()+'.jpg';
	
		//first - read image and crop it
		Jimp.read(fullImage).then( function(cropImage) {

				if (cropRect != null) {
						cropImage.crop(cropRect.x, cropRect.y, cropRect.width, cropRect.height);
				}
				cropImage.write(cropped, function(cb) {

						//second - check if meter read is dark, medium or light
						isImageDark(cropped, function(meterType) {
							 Jimp.read(cropped).then(function (image) {
							 		//third - perform image enhancement
									if (meterType == MeterType.Dark) {
											console.log("Invert image colors");
											image.invert();
									} 

									if (meterType.grayscale) {
											image.grayscale();
									} 

									if (meterType == MeterType.Medium) {
											image.brightness(meterType.brightness); 
											image.contrast(meterType.contrast);
									} else {
											image.contrast(meterType.contrast);
											image.brightness(meterType.brightness); 
									}

									if (meterType.posterize > 0) {
											image.posterize(meterType.posterize);
									}
									
									image.autocrop();
						
									image.write(output, function(cb) {
											performTextCleaner(output, null, null, null, callback);
									});

							}).catch(function (err) {
									callback(err, null);
							});
						});   
				});
		});
   }
 };

	function performTextCleaner(image, brightness, contrast,posterize, callback) {

		var ds = utils.datetimestamp();
		var id = uuid.v4();
		// generate output file name
		var output = Textcleaner.uploadPath + 'meter_photo_' +ds+ '_textcleaner_' + uuid.v4()+'.jpg';

		if (brightness != null || contrast != null || posterize != null) {
				output = Textcleaner.uploadPath + 'meter_photo_b_' +brightness + '_c_' + contrast+ '_p_' + posterize +'_clean.jpg';
		}

		Textcleaner.tmpFiles.push(output);
	
		// assemble Textcleaner command
		var command = [Textcleaner.options.binary]

		//-g -e stretch -f 25 -o 10 -u -s 1 -T
		command.push('-g -e stretch -f 25 -o 10 -u -s 1 -T');
		// add input and output
		command.push(image);
		command.push(output);

		command = command.join(' ');

		console.log('Textcleaner: command')
		console.log(command);

		var opts = Textcleaner.options.env || {};

		// Run the Textcleaner command
		exec(command, opts, function(err) {
			if (err) {
				// Something went wrong executing the assembled command
				callback(err, null);
				return;
			}

			// Find one of the three possible extension
			glob(output, function(err, files){
				if (err) {
					callback(err, null);
					return;
				}

				// we have got transformed image path
				callback(null, output);
			})
		}); // end exec
	}

function gc() {
	for (var i = Textcleaner.tmpFiles.length - 1; i >= 0; i--) {
		try {
			fs.unlinkSync(Textcleaner.tmpFiles[i] + '.txt');
		} catch (err) {}

		var index = Textcleaner.tmpFiles.indexOf(Textcleaner.tmpFiles[i]);
		if (~index) Textcleaner.tmpFiles.splice(index, 1);
	};
}

var version = process.versions.node.split('.').map(function(value) {
	return parseInt(value, 10);
});

if (version[0] === 0 && (version[1] < 9 || version[1] === 9 && version[2] < 5)) {
	process.addListener('uncaughtException', function _uncaughtExceptionThrown(err) {
		gc();
		throw err;
	});
}

// clean up the tmp files
process.addListener('exit', function _exit(code) {
	gc();
});

function isImageDark(image, callback) {
		var checkingPoints = []

		console.log("Checking image brightness");

		lwip.open(image, "jpg",function(err, img) {

				var width = img.width();
				var height = img.height();

				var pixels = arrayOfPixelsToCheck(width, height);

				var dark = 0;
				var medium = 0;
				var light = 0;

				for(var i=0; i<pixels.length; i++) {
						var pixel = pixels[i];
						pixel.color = img.getPixel(pixel.x,pixel.y);
						pixels[i] = pixel;

						var grayValue = getGrayscaleValue(pixel.color);

						if (grayValue < MeterType.Dark.min) {
								dark++;
						} else if (grayValue < MeterType.Medium.min) {
								medium++;
						} else {
								light++;
						}
				}

				var meterType;

				if (dark > medium && dark > light) {
					  meterType = MeterType.Dark;
				} else if (medium > dark && medium > light) {
						meterType = MeterType.Medium;
				} else {
						meterType = MeterType.Light;
				}
			
				// console.log(pixels);
				console.log('Meter type '+meterType.name);

				callback(meterType);
		});

	function arrayOfPixelsToCheck(width, height) {

		var points = [];

		var dividerPerWidth = 7;
		var dividerPerHeight = 3;

		var gapX = width / (dividerPerWidth + 1);
		var x = gapX;

		var gapY = height / (dividerPerHeight + 1);
		var y = gapY;

		var level = 1;

		for (var level = 0; level < dividerPerHeight; level++) {

			for (var col = 0; col < dividerPerWidth; col++) {
					points.push(new Point(x,y));
					x+=gapX;
			}

			x = gapX;
			y += gapY;
		}

		return points;
	}

	function getGrayscaleValue(color){
		var yiq = ((color.r*299)+(color.g*587)+(color.b*114))/1000;
		return yiq;
	}

  function Point(x, y) {
    this.x = parseInt(x);
    this.y = parseInt(y);
    this.color = -1;
  }
};

/**
 * Module exports.
 */
module.exports.process = Textcleaner.process;
module.exports.benchmark = Textcleaner.benchmark;
